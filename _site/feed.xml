<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Darren's Blog</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Thu, 04 Jul 2019 16:36:26 +0800</pubDate>
    
      <item>
        <title>SYS BOX 隐私政策</title>
        <link>/SYS-BOX-Privacy-Policy/</link>
        <guid isPermaLink="true">/SYS-BOX-Privacy-Policy/</guid>
        <description>&lt;p&gt;本软件尊重并保护所有使用服务用户的个人隐私权。本软件将以高度的勤勉、审慎义务对待这些信息。本软件不会将这些信息对外披露或向第三方提供。本软件会不时更新本隐私权政策。您在同意本软件服务使用协议之时，即视为您已经同意本隐私权政策全部内容。本隐私权政策属于本软件服务使用协议不可分割的一部分。&lt;/p&gt;

&lt;h2 id=&quot;一适用范围&quot;&gt;一、适用范围&lt;/h2&gt;
&lt;p&gt;1.在您使用本软件时，本软件会自动读取您的手机上的信息，包括但不限于您使用的语言、地区、软硬件特征信息等数据，所有信息均只用于展示而不会上传到服务器；&lt;/p&gt;

&lt;p&gt;2.为了更好的用户体验，当本软件发生崩溃时，会把崩溃时堆栈信息上传到崩溃日志分析平台，绝不会上传用户隐私信息。&lt;/p&gt;

&lt;h2 id=&quot;二信息的使用&quot;&gt;二、信息的使用&lt;/h2&gt;
&lt;p&gt;1.在您使用本软件时，您所记录的流量套餐信息、应用快捷入口等均只会记录在本地，不会上传到服务器；&lt;/p&gt;

&lt;p&gt;2.当软件发生崩溃时，会把崩溃时堆栈信息上传到崩溃日志分析平台，以便能及时改进软件提升用户体验。&lt;/p&gt;

&lt;h2 id=&quot;三信息披露&quot;&gt;三、信息披露&lt;/h2&gt;
&lt;p&gt;本软件不会将您的信息披露给不受信任的第三方。&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>SYS BOX Privacy Policy</title>
        <link>/SYS-BOX-Privacy-Policy-En/</link>
        <guid isPermaLink="true">/SYS-BOX-Privacy-Policy-En/</guid>
        <description>&lt;p&gt;The software respects and protects the personal privacy of all service users. The software will treat such information with a high degree of diligence and due diligence. The software will not disclose or provide such information to third parties. This software will update this privacy policy from time to time. By agreeing to this software service usage agreement, you shall be deemed to have agreed to the entire content of this privacy policy. This privacy policy is an integral part of the software service usage agreement.&lt;/p&gt;

&lt;h3 id=&quot;1-scope-of-application&quot;&gt;1. Scope of application&lt;/h3&gt;
&lt;p&gt;a) When you use the software, the software will automatically read the information on your phone, including but not limited to the language, region, software and hardware characteristic information and other data you use.&lt;/p&gt;

&lt;p&gt;b) For better user experience, when the software crashes, the stack information will be uploaded to the crash log analysis platform, and user privacy information will never be uploaded.&lt;/p&gt;

&lt;h3 id=&quot;2-use-of-information&quot;&gt;2. Use of information&lt;/h3&gt;
&lt;p&gt;a) When you use the software, the traffic package information and application shortcut entrance you recorded will only be recorded locally, and will not be uploaded to the server;&lt;/p&gt;

&lt;p&gt;b) When the software crashes, the stack information will be uploaded to the crash log analysis platform to improve the software in time to improve the user experience.&lt;/p&gt;

&lt;h3 id=&quot;3-information-disclosure&quot;&gt;3. Information disclosure&lt;/h3&gt;
&lt;p&gt;The software will not disclose your information to an untrusted third party.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>SYS BOX 公告</title>
        <link>/SYS-BOX-Notice/</link>
        <guid isPermaLink="true">/SYS-BOX-Notice/</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; 是一款集合多个实用功能的通知栏小组件的应用，拥有极简的设计和优良的性能表现，功能强大而不累赘。&lt;/p&gt;

&lt;p&gt;你可以在通知中心的“今天”页面里添加 &lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; 里集合小组件，轻松获得以下功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络流量系统信息小组件&lt;/li&gt;
  &lt;li&gt;倒数日小组件&lt;/li&gt;
  &lt;li&gt;快捷入口小组件&lt;/li&gt;
  &lt;li&gt;网络流量监测小组件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; 为专业用户提供了常用的网络工具，如Ping、DNS解析、路由跟踪等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; 提供可定制化的功能，你不仅可以更换应用的图标，还可以随心更换首页的背景并添加酷炫的星空效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; 提前适配了 iOS 13 的黑暗模式，你只需要在应用设置里点击开关，在通知栏上的小组件也可以很好地适配 iOS 13 的黑暗模式。&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>SYS BOX Notice</title>
        <link>/SYS-BOX-Notice-En/</link>
        <guid isPermaLink="true">/SYS-BOX-Notice-En/</guid>
        <description>&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; is an application that integrates multiple functional notification widgets, with a minimalist design and excellent performance. It is powerful but not cumbersome.&lt;/p&gt;

&lt;p&gt;You can easily access the following features by adding collection Widgets from &lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; to the “Today” page of the Notification Center:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Network traffic &amp;amp; system information monitor widget&lt;/li&gt;
  &lt;li&gt;Important events widget&lt;/li&gt;
  &lt;li&gt;Quick starter widget&lt;/li&gt;
  &lt;li&gt;Network traffic monitor widget&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; provides professional users with common networking tools, such as Ping, DNS resolution, routing tracking, etc.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; offers customizable features that not only allow you to change app’s icon, but also allow you to change the background of home page and add cool starry sky effects.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;SYS BOX&lt;/em&gt;&lt;/strong&gt; adapts to iOS 13’s dark mode in advance. You just click on the switch, and the Widgets on the Notification Center also adapt well to iOS 13’s dark mode.&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Jul 2019 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>关于iOS多任务页面底部出现“xxx，早上好”banner的调研</title>
        <link>/iOS-Banners/</link>
        <guid isPermaLink="true">/iOS-Banners/</guid>
        <description>&lt;h3 id=&quot;多任务页面底部banner出现的种类&quot;&gt;多任务页面底部banner出现的种类&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/media/image/ios_bottom_banners_1.png&quot; alt=&quot;Image_1&quot; /&gt;
&lt;strong&gt;&lt;em&gt;1、handoff（接力）
2、xxx，早上好
3、基于您的当前位置
4、“耳机”已连接
5、（未知。。。）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;

&lt;h4 id=&quot;handoff&quot;&gt;handoff&lt;/h4&gt;
&lt;p&gt;设置 -&amp;gt; 通用 -&amp;gt; 接力 -&amp;gt; 打开接力&lt;/p&gt;

&lt;p&gt;通过“接力”功能，您在某设备开始操作后，可立即使用iCloud账号从另一设备继续相同操作。您需要的应用会显示在应用切换器和Mac的程序坞上。&lt;/p&gt;

&lt;p&gt;这种一般应用在需要跨设备共享编辑的应用上，例如“印象笔记”，在手机上编辑了一段文字后，可以切换到Mac上继续编辑。&lt;strong&gt;Bigo Live应该没有这种需求&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;官方简介：https://support.apple.com/zh-cn/HT204681&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;这是开发者唯一能控制的底部banner种类&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;siri应用建议&quot;&gt;Siri应用建议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;xxx，早上好
基于您的当前位置
“耳机”已连接&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;关于前两种情况&quot;&gt;关于前两种情况：&lt;/h5&gt;
&lt;p&gt;系统会记录用户长期的使用应用的习惯，自主地向用户推荐相关的应用。例如，早上起床后我会习惯打开微博，系统早上就会给我推荐微博；来到公司我会习惯打开微信，系统也会根据地理位置给我推荐微信。系统会通过记录用户的使用频率、时间、地理位置等维度，向用户推荐应用。&lt;/p&gt;

&lt;h5 id=&quot;关于耳机已连接&quot;&gt;关于“耳机”已连接&lt;/h5&gt;
&lt;p&gt;手机连接蓝牙耳机或者有线耳机后，系统会弹出 “耳机”已连接 的banner，如果手机装有多个音乐应用，目前观察到的情况是会弹出最常用的那个应用。但是有时候又不会弹，而且弹出维持的时间也没有规律。&lt;/p&gt;

&lt;h5 id=&quot;国外用户如是说&quot;&gt;国外用户如是说：&lt;/h5&gt;
&lt;hr /&gt;
&lt;p&gt;This is a feature suggesting which app you normally use in a certain situation. Like location, time of day, headphones or Bluetooth connected. Phone tries to learn if you always do something. Like I always open maps when I connect to my car Bluetooth. Or always open music when by headphones are plugged in. Or always open weather at 7am.
***&lt;/p&gt;

&lt;h5 id=&quot;用户怎么打开应用推荐&quot;&gt;用户怎么打开应用推荐&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/media/image/ios_bottom_banners_2.png&quot; alt=&quot;Image_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1、设置 -&amp;gt; Siri与搜索 -&amp;gt; 打开 搜索建议 查询建议 锁屏建议
2、设置 -&amp;gt; 隐私 -&amp;gt; 定位服务 -&amp;gt; 系统服务 -&amp;gt; 打开 基于位置的建议 基于位置的提醒
3、通知栏 -&amp;gt; 右滑 -&amp;gt; 编辑 -&amp;gt; 添加 Siri应用建议 小组件&lt;/p&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;iOS多任务页面底部出现“xxx，早上好”banner是一个系统行为，系统的Siri会根据用户的使用习惯，在多任务页面底部显示推荐应用，开发者无法干预。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;https://stackoverflow.com/questions/46039851/how-may-i-customize-app-suggestions-in-ios
https://www.phonearena.com/news/App-suggestions-in-iOS-10-how-they-work-whats-changed-how-to-disable-them_id89219
https://discussions.apple.com/message/30065692#30065692&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Nov 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>iOS利用Speech Kit实现语音识别</title>
        <link>/iOS-Speech-Kit/</link>
        <guid isPermaLink="true">/iOS-Speech-Kit/</guid>
        <description>&lt;p&gt;&lt;img src=&quot;/media/image/speech_kit_1.jpg&quot; alt=&quot;Siri.jpeg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;前一段时间彩云小译上了App Store的推荐，我下载试玩了一下，效果还是非常不错的。它可以实现实时翻译的功能，我自己粗浅地分析了一下彩云小译的实现原理，其中最重要的一步就是声音转文字。&lt;/p&gt;

&lt;p&gt;目前市面上也有很多服务商提供声音转文字的服务，有收费的有免费的，但是毕竟是第三方的服务商，接口的性能和稳定性都不一定能保证。&lt;/p&gt;

&lt;p&gt;2016年Apple在发布重磅产品iOS10的同时也发布了Speech Kit语音识别框架，大名鼎鼎的Siri的语音识别就是基于Speech Kit实现的。有了Speech Kit，我们就可以非常简单地实现声音转文字的功能。下面我就简单介绍一下Speech Kit的用法。&lt;/p&gt;

&lt;h2 id=&quot;二实现&quot;&gt;二、实现&lt;/h2&gt;

&lt;h3 id=&quot;1页面布局&quot;&gt;1、页面布局&lt;/h3&gt;

&lt;p&gt;因为只是实现一个Demo，页面不需要多复杂，只需要在Storyboard上拖入两个控件：一个UITextView用于展示声音转文字的结果，一个UIButton用于触发语音识别，最好布置好约束即可。具体效果如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/image/speech_kit_2.jpg&quot; alt=&quot;控件布局&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2申请用户权限&quot;&gt;2、申请用户权限&lt;/h3&gt;

&lt;p&gt;首先需要引入Speech Kit框架&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Speech/Speech.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;申请权限非常简单，在识别前（viewDidLoad:）加入以下代码即可申请语音识别的权限：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 请求权限
    [SFSpeechRecognizer requestAuthorization:^(SFSpeechRecognizerAuthorizationStatus status) {
        NSLog(@&quot;status %@&quot;, status == SFSpeechRecognizerAuthorizationStatusAuthorized ? @&quot;授权成功&quot; : @&quot;授权失败&quot;);
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这时候运行起来会崩溃，原因是在iOS10后需要在info.plist文件中添加麦克分和语音识别权限申请信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;key&amp;gt;NSSpeechRecognitionUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;请允许语音识别&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;请打开麦克风&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;运行项目，会提示打开语音识别和打开麦克风权限，至此我们已经完成了权限的申请。&lt;/p&gt;

&lt;h3 id=&quot;3初始化语音识别引擎&quot;&gt;3、初始化语音识别引擎&lt;/h3&gt;

&lt;p&gt;添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)initEngine {
    if (!self.speechRecognizer) {
        // 设置语言
        NSLocale *locale = [NSLocale localeWithLocaleIdentifier:@&quot;zh-CN&quot;];
        self.speechRecognizer = [[SFSpeechRecognizer alloc] initWithLocale:locale];
    }
    if (!self.audioEngine) {
        self.audioEngine = [[AVAudioEngine alloc] init];
    }
    
    AVAudioSession *audioSession = [AVAudioSession sharedInstance];
    [audioSession setCategory:AVAudioSessionCategoryRecord mode:AVAudioSessionModeMeasurement options:AVAudioSessionCategoryOptionDuckOthers error:nil];
    [audioSession setActive:YES withOptions:AVAudioSessionSetActiveOptionNotifyOthersOnDeactivation error:nil];
    
    if (self.recognitionRequest) {
        [self.recognitionRequest endAudio];
        self.recognitionRequest = nil;
    }
    self.recognitionRequest = [[SFSpeechAudioBufferRecognitionRequest alloc] init];
    self.recognitionRequest.shouldReportPartialResults = YES; 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;初始化&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechRecognizer&lt;/code&gt;时需要传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLocle&lt;/code&gt;对象，用于标识用户输入的语种，如”zh-CN”代表普通话，”en_US”代表英文。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AVAudioEngine&lt;/code&gt;是音频引擎，用于音频输入。&lt;/li&gt;
  &lt;li&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;AVAudioSession&lt;/code&gt;对象进行音频录制的配置。&lt;/li&gt;
  &lt;li&gt;在语音识别产生最终结果之前可能产生多种结果，设置&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechAudioBufferRecognitionRequest&lt;/code&gt;对象的&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldReportPartialResult&lt;/code&gt;属性为YES意味着每产生一种结果就马上返回。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4启动语音识别引擎&quot;&gt;4、启动语音识别引擎&lt;/h3&gt;

&lt;p&gt;添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)startRecording:(UIButton *)recordButton {
    [self initEngine];
    
    AVAudioFormat *recordingFormat = [[self.audioEngine inputNode] outputFormatForBus:0];
    [[self.audioEngine inputNode] installTapOnBus:0 bufferSize:1024 format:recordingFormat block:^(AVAudioPCMBuffer * _Nonnull buffer, AVAudioTime * _Nonnull when) {
        [self.recognitionRequest appendAudioPCMBuffer:buffer];
    }];
    [self.audioEngine prepare];
    [self.audioEngine startAndReturnError:nil];
    
    [recordButton setTitle:@&quot;录音ing&quot; forState:UIControlStateNormal];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;self.recordButton&lt;/code&gt;添加点击事件。&lt;/li&gt;
  &lt;li&gt;设置音频录制的格式及音频流回调的处理(把音频流拼接到&lt;code class=&quot;highlighter-rouge&quot;&gt;self.recognitionRequest&lt;/code&gt;)。&lt;/li&gt;
  &lt;li&gt;开始录制音频。&lt;/li&gt;
  &lt;li&gt;修改按钮文案。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5重置语音识别引擎&quot;&gt;5、重置语音识别引擎&lt;/h3&gt;

&lt;p&gt;添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)stopRecording:(UIButton *)recordButton {
    [[self.audioEngine inputNode] removeTapOnBus:0];
    [self.audioEngine stop];
    
    [self.recognitionRequest endAudio];
    self.recognitionRequest = nil;
    
    [recordButton setTitle:@&quot;录音&quot; forState:UIControlStateNormal];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;self.recordButton&lt;/code&gt;添加点击事件。&lt;/li&gt;
  &lt;li&gt;停止音频录制引擎。&lt;/li&gt;
  &lt;li&gt;停止识别器。&lt;/li&gt;
  &lt;li&gt;修改按钮文案。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;6语音识别结果的回调&quot;&gt;6、语音识别结果的回调&lt;/h3&gt;

&lt;p&gt;下面是语音识别器&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechRecognizer&lt;/code&gt;的API描述：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Recognize speech utterance with a request
// If request.shouldReportPartialResults is true, result handler will be called
// repeatedly with partial results, then finally with a final result or an error.
- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request
                                          resultHandler:(void (^)(SFSpeechRecognitionResult * __nullable result, NSError * __nullable error))resultHandler;

// Advanced API: Recognize a custom request with with a delegate
// The delegate will be weakly referenced by the returned task
- (SFSpeechRecognitionTask *)recognitionTaskWithRequest:(SFSpeechRecognitionRequest *)request
                                               delegate:(id &amp;lt;SFSpeechRecognitionTaskDelegate&amp;gt;)delegate;                                           
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;语音识别结果的回调有两种方式，一种是delegate，一种是block，这里为了简单，先采用block的方式回调。&lt;/p&gt;

&lt;p&gt;初始化语音识别器&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechRecognizer&lt;/code&gt;时添加以下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self.speechRecognizer recognitionTaskWithRequest:self.recognitionRequest resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {
        NSLog(@&quot;is final: %d  result: %@&quot;, result.isFinal, result.bestTranscription.formattedString);
        if (result.isFinal) {
            self.textView.text = [NSString stringWithFormat:@&quot;%@%@&quot;, self.textView.text, result.bestTranscription.formattedString];
        }
    }];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7识别音频文件&quot;&gt;7、识别音频文件&lt;/h3&gt;

&lt;p&gt;添加以下代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (IBAction)startRecognizing:(id)sender {
    SFSpeechRecognizer *recognizer = [[SFSpeechRecognizer alloc] initWithLocale:[NSLocale localeWithLocaleIdentifier:@&quot;zh_CN&quot;]];
    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;test.mp3&quot; withExtension:nil];
    SFSpeechURLRecognitionRequest *request = [[SFSpeechURLRecognitionRequest alloc] initWithURL:url];
    [recognizer recognitionTaskWithRequest:request resultHandler:^(SFSpeechRecognitionResult * _Nullable result, NSError * _Nullable error) {
        if (result.isFinal) {
            UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;识别结果&quot; message:[NSString stringWithFormat:@&quot;%@&quot;, result.bestTranscription.formattedString] preferredStyle:UIAlertControllerStyleAlert];
            UIAlertAction *confirm = [UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleCancel handler:nil];
            [alert addAction:confirm];
            [self presentViewController:alert animated:YES completion:nil];
        }
    }];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;初始化语音识别器&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechRecognizer&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;获取音频文件路径。&lt;/li&gt;
  &lt;li&gt;初始化语音识别请求&lt;code class=&quot;highlighter-rouge&quot;&gt;SFSpeechURLRecognitionRequest&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;设置回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;本文章主要介绍了如何利用iOS系统自带的Speech Kit框架实现音频转文字的功能，Speech Kit相当强大，本文章只是非常简单的介绍了录音识别及音频文件识别而已，大家有兴趣可以深入研究，有问题也可以一起探讨。&lt;/p&gt;

&lt;p&gt;声音转文字的功能我们已经实现了，下一步我们可以找到翻译服务提供商的服务，就可以实现一个简易版的实时翻译应用了。&lt;/p&gt;

&lt;p&gt;本文Demo：&lt;a href=&quot;https://github.com/OuDuShu/SpeechTest&quot;&gt;https://github.com/OuDuShu/SpeechTest&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四参考&quot;&gt;四、参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://swift.gg/2016/09/30/siri-speech-framework/&quot;&gt;http://swift.gg/2016/09/30/siri-speech-framework/&lt;/a&gt;
&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2016/509/&quot;&gt;https://developer.apple.com/videos/play/wwdc2016/509/&lt;/a&gt;
&lt;a href=&quot;https://developer.nuance.com/public/Help/DragonMobileSDKReference_iOS/Getting-started.html&quot;&gt;https://developer.nuance.com/public/Help/DragonMobileSDKReference_iOS/Getting-started.html&lt;/a&gt;
&lt;a href=&quot;https://www.raywenderlich.com/60870/building-ios-app-like-siri&quot;&gt;https://www.raywenderlich.com/60870/building-ios-app-like-siri&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Dec 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>在树莓派上部署ATC网络模拟工具（Augmented Traffic Control）</title>
        <link>/Raspberry-ATC/</link>
        <guid isPermaLink="true">/Raspberry-ATC/</guid>
        <description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;作为移动开发者的我们，为了良好的用户体验，经常需要模拟手机应用在比较差的网络环境下的表现，模拟网络环境的方式有很多，比如使用Charles，或者在手机的开发者模式下模拟网络环境等等，但是这些都有一定的门槛。&lt;/p&gt;

&lt;p&gt;使用Charles，首先你得连接WiFi，然后设置代理，接着开启网络模拟模式，最后测试完了如果忘了关闭代理，可能手机就上不了网了。而且都连上你电脑的代理的话就一次只能模拟一种网络环境。&lt;/p&gt;

&lt;p&gt;使用手机的开发者模式，首先你的手机能进入开发者模式。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;如果你需要随便抓一位不懂技术同事帮你测试，这些方式都不太友好，有没有一种方式可以连上WiFi就可以使用的测试方式呢？有！接下来就介绍Facebook出品的一款网络模拟工具ATC。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;二简介&quot;&gt;二、简介&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Augmented Traffic Control (ATC) is a tool to simulate network conditions. It allows controlling the connection that a device has to the internet. Developers can use ATC to test their application across varying network conditions, easily emulating high speed, mobile, and even severely impaired networks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ATC全名叫Augmented Traffic Control，是Facebook出品的一款网络模拟工具，移动开发者可以通过这款工具模拟不同条件下的网络环境，可以通过网页自由地模拟网络带宽（bandwidth）、延迟（latency）、丢包率（packet loss）、错包率（corrupted packets）和乱序率（packets ordering）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;而且！！！更牛逼的是：不同的设备连接到同一WiFi还可以模拟不同的网络环境互不影响。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/99a779517d18a605046dec36d2beb02166f4e77b/68747470733a2f2f66616365626f6f6b2e6769746875622e696f2f6175676d656e7465642d747261666669632d636f6e74726f6c2f696d616765732f6174635f6f766572766965772e706e67&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/facebook/augmented-traffic-control&quot;&gt;github地址&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;三准备&quot;&gt;三、准备&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1、树莓派3（已内置有无线网卡）&lt;br /&gt;
2、已刷入最新RASPBIAN系统的SD卡&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;四安装&quot;&gt;四、安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;安装主要有两步：&lt;br /&gt;
1、让树莓派有发射AP热点的能力；&lt;br /&gt;
2、安装ATC。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;1让树莓派有发射ap热点的能力&quot;&gt;1、让树莓派有发射AP热点的能力&lt;/h3&gt;
&lt;p&gt;1.安装hostapd虚拟热点程序和dnsmasq配置DHCP、DNS服务程序：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt-get install dnsmasq hostapd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;2.编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim /etc/dhcpcd.conf&lt;/code&gt;文件，在该文件的最后加入下面的命令，用来为wlan0固定一个内网IP。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface wlan0
static ip_address=10.0.0.1/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim /etc/dnsmasq.conf&lt;/code&gt;dnsmasq配置文件，有600+行的内容，我们可以&lt;code class=&quot;highlighter-rouge&quot;&gt;shift+g&lt;/code&gt;滚动到最下面，然后加入下面的命令，用来控制IP地址的取值范围&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface=wlan0
dhcp-range=10.0.0.2,10.0.0.50,255.255.255.0,12h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.添加hostapd.conf配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim /etc/hostapd/hostapd.conf&lt;/code&gt;并添加下面内容，用于配置热点的账号密码等信息。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssid=PI3                 #账号
wpa_passphrase=12345678  #密码
interface=wlan0
driver=nl80211
hw_mode=g
channel=10
macaddr_acl=0
auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
rsn_pairwise=CCMP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.编辑sysctl.conf文件，设置路由转发&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim /etc/sysctl.conf&lt;/code&gt;，打开下面的注释&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Uncomment the next line to enable packet forwarding for IPv4
net.ipv4.ip_forward=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;6.更新iptables规则，依次执行下面命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT
sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT
sudo sh -c &quot;iptables-save &amp;gt; /etc/iptables.ipv4.nat&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;7.编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim /etc/network/interfaces&lt;/code&gt;，在最后加入下面的命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;up iptables-restore &amp;lt; /etc/iptables.ipv4.nat
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;8.重启树莓派后执行下面命令，如无意外就可以发射热点了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo service hostapd start 
sudo service dnsmasq start 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2安装atc&quot;&gt;2、安装ATC&lt;/h3&gt;
&lt;p&gt;ATC需要依赖Python环境，RASPBIAN系统默认已经支持Python，所以不用再安装，如果你的是Ubuntu或者其他Linux系统，你需要输入下面命令先安装Python的依赖，并安装pip包管理工具。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install python-pip python-dev build-essential）
sudo pip install --upgrade pip 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;1.安装ATC依赖库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pip install atc_thrift atcd django-atc-api django-atc-demo-ui django-atc-profile-storage
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意这里要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;，不然会因没有权限而安装失败。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.创建新的Django项目&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;django-admin startproject atcui
cd atcui
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.编辑settings.py文件&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vim atcui/settings.py&lt;/code&gt;，并在INSTALLED_APPS的后面加入下面参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = (
    ...
    # Django ATC API
    'rest_framework',
    'atc_api',
    # Django ATC Demo UI
    'bootstrap_themes',
    'django_static_jquery',
    'atc_demo_ui',
    # Django ATC Profile Storage
    'atc_profile_storage',
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;4.编辑urls.py文件，并加入下面内容&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd atcui
sudo vim urls.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
...
from django.views.generic.base import RedirectView
from django.conf.urls import include

urlpatterns = [
    ...
    # Django ATC API
    url(r'^api/v1/', include('atc_api.urls')),
    # Django ATC Demo UI
    url(r'^atc_demo_ui/', include('atc_demo_ui.urls')),
    # Django ATC profile storage
    url(r'^api/v1/profiles/', include('atc_profile_storage.urls')),
    url(r'^$', RedirectView.as_view(url='/atc_demo_ui/', permanent=False)),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5.更新Django数据库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python manage.py migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到这里，我们已经完成整个环境的部署，步骤有点多，只要一步一步做，应该不会出问题。&lt;/p&gt;

&lt;h2 id=&quot;五使用&quot;&gt;五、使用&lt;/h2&gt;

&lt;p&gt;1、启动核心组件atcd&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo atcd --atcd-lan wlan0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;出现&lt;code class=&quot;highlighter-rouge&quot;&gt;Awaiting graceful shutdown.&lt;/code&gt;后按&lt;code class=&quot;highlighter-rouge&quot;&gt;Ctrl+c&lt;/code&gt;退出。&lt;/p&gt;

&lt;p&gt;2、启动Django工程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ..
sudo python manage.py runserver 0.0.0.0:8000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3、移动设备连接WiFi，使用浏览器输入&lt;code class=&quot;highlighter-rouge&quot;&gt;10.0.0.1:8000/atc_demo_ui/&lt;/code&gt;即可进入控制中心，添加网络配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-b5a55cc4fb0223a9.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;控制中心&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALLOWED_HOSTS = [‘10.0.0.1’]&lt;/p&gt;

&lt;h2 id=&quot;六坑&quot;&gt;六、坑&lt;/h2&gt;

&lt;p&gt;在部署ATC工具的过程中，我遇到过三个坑，还好解决起来不太难，希望大家再遇到的时候可以快速解决。&lt;/p&gt;

&lt;h3 id=&quot;1权限问题&quot;&gt;1、权限问题&lt;/h3&gt;
&lt;p&gt;安装ATC依赖库时没有权限，在命令签名加上&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;2invalid-http_host-header-xxx-you-may-need-to-add-uxxx-to-allowed_hosts&quot;&gt;2、Invalid HTTP_HOST header :’xxx’. You may need to add u’xxx’ to ALLOWED_HOSTS.&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-00763262ef56bcd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候只需要编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;atcui&lt;/code&gt;目录下的&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;文件，在ALLOWED_HOSTS后加上本机ip即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALLOWED_HOSTS = ['10.0.0.1']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3成功进入控制中心但是中间提示atc-is-not-running&quot;&gt;3、成功进入控制中心，但是中间提示&lt;em&gt;ATC is not running&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Google了一下，发现还蛮多人遇到同样的问题，下面是作者的回复：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-16c0a2c5e0586568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ATC is not running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/augmented-traffic-control/issues/153&quot;&gt;Issues地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;根据作者的提示，我重新安装了&lt;code class=&quot;highlighter-rouge&quot;&gt;django-rest-framework&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install django-rest-framework
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后重启服务即可。&lt;/p&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>对iOS数据安全的一次小探索</title>
        <link>/iOS-Security/</link>
        <guid isPermaLink="true">/iOS-Security/</guid>
        <description>&lt;h2 id=&quot;一主流保证数据安全的方式&quot;&gt;一、主流保证数据安全的方式&lt;/h2&gt;
&lt;h3 id=&quot;1网络传输安全&quot;&gt;1、网络传输安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.采用HTTPS通信协议&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
可防止抓包窃取、篡改传输数据，大大增加了中间人攻击的成本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.对敏感数据进行签名校正&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
采用非对称加密的方式，对敏感数据使用密钥加密，到了客户端用公钥解密，验证数据一致性，防止通信过程中被篡改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.采用密文传输&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
别人即使截取了传输信息，也无法看懂其中的意思。&lt;/p&gt;

&lt;h3 id=&quot;2本地存储数据安全&quot;&gt;2、本地存储数据安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.数据库加密&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
通过越狱设备可以很容易地把整个应用包（包括里面的数据）copy出来，这样就可以获取里面的数据库，对于没有加密的数据库就可以非常轻易地读取里面的信息，造成信息的泄漏。
&lt;strong&gt;&lt;em&gt;数据库加密可分两个维度：1.整个数据库加密；2.对部分字段先加密再存数据库。&lt;/em&gt;&lt;/strong&gt;
&lt;strong&gt;&lt;em&gt;对部分字段加密并不适合多字段的加密存储，容易导致加密数据太过分散，影响性能。所以推荐对整个数据库加密。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.KeyChain存储敏感数据&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
KeyChain是iOS系统级的存储方式，安全性无需质疑，且删除应用或者升级系统依然可以保留里面的信息。&lt;/p&gt;

&lt;h3 id=&quot;3源码安全&quot;&gt;3、源码安全&lt;/h3&gt;

&lt;p&gt;使用越狱设备可以很轻易地把应用砸壳，从而把源码dump下来，即使是没有太多经验的开发者也可以得到应用的类信息，包括函数名等。使用IDA等反编译工具可以看到应用的一些类名和方法名，进而可以分析功能实现的逻辑。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.字符串混淆&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
对应用程序中使用到的字符串进行加密，保证源码被逆向后也能保护明文字符串。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.类名、方法名混淆&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
市面上很多iOS应用都没有混淆类名方法名，以致于很容易使用class-dump下来，从而进行hook操作，&lt;a href=&quot;http://www.jianshu.com/p/189afbe3b429&quot;&gt;一步一步实现iOS微信自动抢红包(非越狱)&lt;/a&gt;是很有趣的一个应用。&lt;a href=&quot;https://github.com/Polidea/ios-class-guard&quot;&gt;这个库&lt;/a&gt;可以混淆OC的类名、协议、属性还有方法名。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;3.程序结构混淆加密&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低。&lt;a href=&quot;https://github.com/obfuscator-llvm/obfuscator/&quot;&gt;可参考这个库&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;4.反调试、反注入等一些主动保护策略&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
加入第三方安全性SDK&lt;/p&gt;

&lt;h2 id=&quot;二对数据库加密的研究&quot;&gt;二、对数据库加密的研究&lt;/h2&gt;
&lt;h3 id=&quot;1主流数据库加密方式&quot;&gt;1、主流数据库加密方式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The SQLite Encryption Extension（收费）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;SQLiteEncrypt（收费）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;SQLiteCrypt（收费）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;SQLCipher（开源免费）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;只有SQLCipher是免费的，所以本文主要对SQLCipher进行研究。&lt;/p&gt;
&lt;h3 id=&quot;2引入sqlcipher第三方库&quot;&gt;2、引入SQLCipher第三方库&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;1.手动引入&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
请参考&lt;a href=&quot;https://www.zetetic.net/sqlcipher/ios-tutorial/&quot;&gt;官方教程&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;2.使用CocoaPods&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;pod 'FMDB/SQLCipher', '2.5'&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;3sqlcipher的可行性研究&quot;&gt;3、SQLCipher的可行性研究&lt;/h3&gt;
&lt;h4 id=&quot;1新建加密数据库&quot;&gt;1.新建加密数据库&lt;/h4&gt;
&lt;p&gt;若没有旧数据的情况下使用很简单，只需要在FMDatabase里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;-open&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;-openWithFlags:&lt;/code&gt;方法里面添加&lt;code class=&quot;highlighter-rouge&quot;&gt;[self setKey:kDatabaseEncryptKey];&lt;/code&gt;即可。
如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-17fbeb85a0beb88f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;添加密钥&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是在团队协作中，如果直接修改pod仓库里面的文件，可能不好同步，下面有一个技巧，就是继承FMDatabase和FMDatabaseQueue并重载其中的方法。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;继承FMDatabase的子类需要重载以下方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (BOOL)open {
    if (_db) {
        return YES;
    }
    int err = sqlite3_open([self sqlitePath], &amp;amp;_db );
    if(err != SQLITE_OK) {
        NSLog(@&quot;error opening!: %d&quot;, err);
        return NO;
    } else {
        // 设置密钥
        [self setKey:kDatabaseEncryptKey];
    }
    if (_maxBusyRetryTimeInterval &amp;gt; 0.0) {
        // set the handler
        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];
    }
    return YES;
}

- (BOOL)openWithFlags:(int)flags {
    if (_db) {
        return YES;
    }
    int err = sqlite3_open_v2([self sqlitePath], &amp;amp;_db, flags, NULL /* Name of VFS module to use */);
    if(err != SQLITE_OK) {
        NSLog(@&quot;error opening!: %d&quot;, err);
        return NO;
    } else {
        // 设置密钥
        [self setKey:kDatabaseEncryptKey];
    }
    if (_maxBusyRetryTimeInterval &amp;gt; 0.0) {
        // set the handler
        [self setMaxBusyRetryTimeInterval:_maxBusyRetryTimeInterval];
    }
    return YES;
}

- (const char*)sqlitePath {
    if (!_databasePath) {
        return &quot;:memory:&quot;;
    }
    if ([_databasePath length] == 0) {
        return &quot;&quot;; // this creates a temporary database (it's an sqlite thing).
    }
    return [_databasePath fileSystemRepresentation];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;继承FMDatabaseQueue的子类只需要重载一个方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (Class)databaseClass {
    return [FMEncryptDatabase class];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用的时候只需要更改下面的语句&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 原：
self.normalQueue = [FMDatabaseQueue databaseQueueWithPath:self.normalDbPath];
// 改为：
self.encryptQueue = [FMEncryptDatabaseQueue databaseQueueWithPath:self.encryptDbPath];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2加密已有数据库&quot;&gt;2.加密已有数据库&lt;/h4&gt;

&lt;p&gt;加密已有数据库我已经封装成下面的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 加密数据库（保留原有数据库）
 */
+ (BOOL)encryptDatabase:(NSString *)origPath toPath:(NSString *)toPath {
    sqlite3 *db;
    if (sqlite3_open([origPath UTF8String], &amp;amp;db) == SQLITE_OK) {
        char *err = NULL;
        sqlite3_exec(db, [[NSString stringWithFormat:@&quot;ATTACH DATABASE '%@' AS encrypted KEY '%@';&quot;, toPath, kDatabaseEncryptKey] UTF8String], NULL, NULL, &amp;amp;err);
        sqlite3_exec(db, &quot;SELECT sqlcipher_export('encrypted');&quot;, NULL, NULL, &amp;amp;err);
        sqlite3_exec(db, &quot;DETACH DATABASE encrypted;&quot;, NULL, NULL, &amp;amp;err);
        sqlite3_close(db);
        return err ? NO : YES;
    } else {
        sqlite3_close(db);
        NSLog(@&quot;Open db failed:%s&quot;, sqlite3_errmsg(db));
        return NO;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里有两点需要注意的地方：&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;1、这里必须使用全路径&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;2、加密后的queue必须同步更换为FMEncryptDatabaseQueue，不然无法读写数据&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;3解密已加密数据库&quot;&gt;3.解密已加密数据库&lt;/h4&gt;
&lt;p&gt;解密已加密的数据库已封装为以下方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 解密数据库（保留原有数据库）
 */
+ (BOOL)unencryptDatabase:(NSString *)origPath toPath:(NSString *)toPath {
    sqlite3 *db;
    if (sqlite3_open([origPath UTF8String], &amp;amp;db) == SQLITE_OK) {
        char *err = NULL;
        sqlite3_exec(db, [[NSString stringWithFormat:@&quot;PRAGMA key = '%@';&quot;, kDatabaseEncryptKey] UTF8String], NULL, NULL, &amp;amp;err);
        sqlite3_exec(db, [[NSString stringWithFormat:@&quot;ATTACH DATABASE '%@' AS plaintext KEY '';&quot;, toPath] UTF8String], NULL, NULL, NULL);
        sqlite3_exec(db, &quot;SELECT sqlcipher_export('plaintext');&quot;, NULL, NULL, &amp;amp;err);
        sqlite3_exec(db, &quot;DETACH DATABASE plaintext;&quot;, NULL, NULL, &amp;amp;err);
        sqlite3_close(db);
        
        return err ? NO : YES;
    } else {
        sqlite3_close(db);
        NSLog(@&quot;Open db failed:%s&quot;, sqlite3_errmsg(db));
        return NO;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里也有两点需要注意的地方：&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;1、这里必须使用全路径&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;2、解密后的queue必须同步更换为FMDatabaseQueue，不然无法读写数据&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;4sqlcipher性能分析&quot;&gt;4、SQLCipher性能分析&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;本次性能分析主要从两个维度下手：
1.对比无加密数据库和加密数据库的插入数据速度；
2.加密已有数据的数据库耗时。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;本次测试都基于iOS10.3的iPad mini2下进行。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;1对比插入数据速度&quot;&gt;1.对比插入数据速度&lt;/h4&gt;
&lt;p&gt;规则：对比无加密数据库和加密数据库使用事务时，在插入1w条、5w条和10w条8个字段的数据的耗时，每组数据测试5次，最后取平均值。最后的测试结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-bb2ea812ee888603.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;插入测试结果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;结论：两者相差在4%左右，在移动设备上存储大数据的情况很少，所以我认为是完全可以接受的。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;2测试加密数据库耗时&quot;&gt;2.测试加密数据库耗时&lt;/h4&gt;
&lt;p&gt;规则：对比存储1w条、5w条和10w条数据的数据库加密的耗时，每组数据测试5次，最后取平均值。最后的测试结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/989987-7bd94c957951fd08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加密耗时测试结果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;结论：加密过程需要一定的时间，且跟数据库所存储的数据量有关，数据量越大耗时越长，从本次的测试结果来看，加密存储10w条数据的数据库耗时1.38s是可以接受的。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;5采用sqlcipher存在的风险&quot;&gt;5、采用SQLCipher存在的风险&lt;/h3&gt;
&lt;p&gt;1、SQLCipher依赖本地存储的字符串进行数据库的加密和解密，如果这个字符串被泄漏出去，本地的数据库依然容易被解密，进而被读取里面的信息。可采用KeyChain保存？
 2、加密已存储大数据的数据库会消耗一定的时间，这段时间怎么处理才能让用户无感知？加密失败了怎么处理？
3、欢迎大家补充。。。&lt;/p&gt;
&lt;h3 id=&quot;6本文demo&quot;&gt;6、&lt;a href=&quot;https://github.com/OuDuShu/SQLCipherDemo&quot;&gt;本文demo&lt;/a&gt;&lt;/h3&gt;
</description>
        <pubDate>Thu, 30 Mar 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>利用树莓派+RetroPie做一个怀旧游戏机</title>
        <link>/Raspberry-RestroPie/</link>
        <guid isPermaLink="true">/Raspberry-RestroPie/</guid>
        <description>&lt;p&gt;RetroPie
一、前言
偶尔会好怀念小时候跟朋友一起玩小霸王的日子，那时候很少家里有游戏机的人，一台游戏机有好几个朋友在等着玩，那时候能玩的东西不多，但日子过得简单而开心。虽说现在万能的淘宝还可以买到小霸王游戏机，但是远远不如自己做一个出来的成就感来的强。下面就一步一步把小时候的游戏机做出来。&lt;/p&gt;

&lt;p&gt;二、准备
1、树莓派+SD卡&lt;/p&gt;

&lt;p&gt;2、显示器、游戏手柄、键盘等外设&lt;/p&gt;

&lt;p&gt;三、下载RetroPie镜像
RetroPie是一个开源的游戏模拟器，可以让你的树莓派或者PC变成一个复古游戏机，它集成了任天堂红白机、GameBoy、SNES等著名游戏系统，具有很高的可玩性。&lt;/p&gt;

&lt;p&gt;你可以在Raspbian直接安装RetroPie，但是会耗费很长的时间，所以我在这里选择直接下载RetroPie镜像。&lt;/p&gt;

&lt;p&gt;下载地址：https://retropie.org.uk/download/&lt;/p&gt;

&lt;p&gt;四、往SD卡写入RetroPie镜像
PC上可以使用 Win32DiskImager 工具写入镜像；&lt;/p&gt;

&lt;p&gt;Mac系统下可以用 ApplePi-Baker 工具；&lt;/p&gt;

&lt;p&gt;具体写入方法及下载地址网上都很容易找到，在这里就不再赘述。&lt;/p&gt;

&lt;p&gt;把已经写入RetroPie镜像的SD卡插入树莓派并连接电源。&lt;/p&gt;

&lt;p&gt;五、配置
1.设置输入设备
我们的游戏手柄有时候并没有那么多个键位，我们在设置的时候怎么跳过一个键位的设置呢？这里有个小技巧：长按“下”键即可跳过。&lt;/p&gt;

&lt;p&gt;设置游戏手柄键位
2.连接WiFi
设置好键位后，我们就可以进入主界面，上面有“13 GAMES AVAILABLE”字样，这并不是意味着里面就有13个游戏可以马上玩的，应该理解为内置了13个游戏模拟器，这时候我们怎么样才能开始玩呢？&lt;/p&gt;

&lt;p&gt;初始主界面
按“A”键，进入设置界面，点击WIFI，连接你电脑同一个的局域网。&lt;/p&gt;

&lt;p&gt;连接局域网
3.传输roms
打开PC，点击“计算机”上面的地址栏，输入“\retropie\roms”，即可进入游戏roms文件夹，把下载好的游戏rom拉到对应的模拟器文件夹，如.nes后缀的游戏rom拉进对应的nes文件夹。&lt;/p&gt;

&lt;p&gt;模拟器文件夹
4.重启模拟器&lt;/p&gt;

&lt;p&gt;重启模拟器
重启模拟器后就可以看到主界面多了一个选项，选择游戏就可以开始你的怀旧之旅了！&lt;/p&gt;

&lt;p&gt;多了一个选项&lt;/p&gt;

&lt;p&gt;超级马里奥
六、其他配置
有人会发现自己的SD卡的内存明明很大，但是没有塞多少个游戏内存就满了，可以进行下面的配置“扩展”内存：&lt;/p&gt;

&lt;p&gt;进入RetroPie的设置界面，进入RASPI-CONFIG&lt;/p&gt;

&lt;p&gt;RASPI-CONFIG
选择第一项Expand Filesystem，重启树莓派即可扩展内存了。&lt;/p&gt;

&lt;p&gt;另外，你还可以在这里进行修改登录密码、国际化选项、设置超频等操作。&lt;/p&gt;

&lt;p&gt;树莓派设置界面
七、祝你玩得开心😊&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Mar 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>iOS 性能优化汇总</title>
        <link>/iOS-Performance-Optimization/</link>
        <guid isPermaLink="true">/iOS-Performance-Optimization/</guid>
        <description>&lt;p&gt;参考：https://i.cmgine.net/archives/14896.html&lt;/p&gt;

&lt;p&gt;入门：
1、用ARC管理内存
2、在正确的地方使用reuseIdentifier
3、尽量吧views设置为完全不透明
4、避免过于庞大的xib
5、不要阻塞主线程
6、不要在ImageView中调整图片大小，尽量使用UIImageView大小相同的图片
7、选择正确的Collection
Arrays: 有序的一组值。使用index来lookup很快，使用value lookup很慢， 插入/删除很慢。&lt;/p&gt;

&lt;p&gt;Dictionaries: 存储键值对。 用键来查找比较快。&lt;/p&gt;

&lt;p&gt;Sets: 无序的一组值。用值来查找很快，插入/删除很快。&lt;/p&gt;

&lt;p&gt;8、打开gzip压缩&lt;/p&gt;

&lt;p&gt;中级：
1、重用和懒加载views
2、Cache，缓存不大可能改变但是需要经常读取的东西（NSCache）
3、权衡渲染方法（View？CALayer？CoreGraphics？OpenGL？）
4、处理内存警告
在app delegate中使用applicationDidReceiveMemoryWarning:的方法&lt;/p&gt;

&lt;p&gt;在你的自定义UIViewController的子类(subclass)中覆盖didReceiveMemoryWarning&lt;/p&gt;

&lt;p&gt;注册并接收 UIApplicationDidReceiveMemoryWarningNotification 的通知&lt;/p&gt;

&lt;p&gt;5、重用大开销对象（如NSDateFormatter，NSCalendar）
6、使用Sprite Sheets
7、避免反复处理数据
解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。&lt;/p&gt;

&lt;p&gt;但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。&lt;/p&gt;

&lt;p&gt;8、正确设定背景图片
使用UIColor的 colorWithPatternImage来设置背景色；&lt;/p&gt;

&lt;p&gt;在view中添加一个UIImageView作为一个子View。（不使用“imageName:”）&lt;/p&gt;

&lt;p&gt;9、减少使用Web特性
10、设定Shadow Path
view.layer.shadowPath = [[UIBezierPath bezierPathWithRect:view.bounds] CGPath];&lt;/p&gt;

&lt;p&gt;11、优化UITableView
正确使用reuseIdentifier来重用cells&lt;/p&gt;

&lt;p&gt;尽量使所有的view opaque，包括cell自身&lt;/p&gt;

&lt;p&gt;避免渐变，图片缩放，后台选人&lt;/p&gt;

&lt;p&gt;缓存行高&lt;/p&gt;

&lt;p&gt;如果cell内现实的内容来自web，使用异步加载，缓存请求结果&lt;/p&gt;

&lt;p&gt;使用shadowPath来画阴影&lt;/p&gt;

&lt;p&gt;减少subviews的数量&lt;/p&gt;

&lt;p&gt;尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用一次然后缓存结果&lt;/p&gt;

&lt;p&gt;使用正确的数据结构来存储数据&lt;/p&gt;

&lt;p&gt;尽量使用rowHeight,sectionFooterHeight和sectionHeaderHeight来设定固定的高，不要请求delegate&lt;/p&gt;

&lt;p&gt;12、选择正确的数据存储选项
使用NSUerDefaults&lt;/p&gt;

&lt;p&gt;使用XML, JSON, 或者 plist&lt;/p&gt;

&lt;p&gt;使用NSCoding存档&lt;/p&gt;

&lt;p&gt;使用类似SQLite的本地SQL数据库&lt;/p&gt;

&lt;p&gt;使用 Core Data&lt;/p&gt;

&lt;p&gt;进阶：
1、加速启动时间
2、使用Autorelease Pool
3、选择是否缓存图片
4、避免日期格式转换&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Feb 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>事件传递：响应者链条（译）</title>
        <link>/iOS-Response-Chain/</link>
        <guid isPermaLink="true">/iOS-Response-Chain/</guid>
        <description>&lt;p&gt;Reveal是一款UI调试工具，在iOS开发过程中可查看UI的层级关系并可动态修改界面，可以有效提高开发效率。这篇文章主要介绍如何把Reveal集成到实际的项目中。&lt;/p&gt;

&lt;p&gt;一、Reveal主要有两种集成方式：
1、framework集成（可忽略，直接看第二点）
（1）打开Reveal，选择 Reveal –&amp;gt; Help –&amp;gt; Show Reveal Library in Finder –&amp;gt; iOS Library&lt;/p&gt;

&lt;p&gt;（2）把Reveal.framework导入到项目中&lt;/p&gt;

&lt;p&gt;（3）配置Target，Target –&amp;gt; Build Setting –&amp;gt; Other Linker Flags 添加以下4项：&lt;/p&gt;

&lt;p&gt;（4）运行项目 –&amp;gt; 打开Reveal –&amp;gt; 选择连接设备&lt;/p&gt;

&lt;p&gt;项目的UI图层就可以出来了。&lt;/p&gt;

&lt;p&gt;这种方法有几个弊端：1、需要配置项目的Build Setting，修改Other Linker Flags，多人协作开发的话如果有人没有配置就会编译出错；2、如果不留意容易打包的时候把Reveal的framework也打包进去，增大包的体积。&lt;/p&gt;

&lt;p&gt;以下推荐另一种集成方法。&lt;/p&gt;

&lt;p&gt;2、LLDB集成（推荐！！）
（1）运行项目 –&amp;gt; 点击Pause program execution。&lt;/p&gt;

&lt;p&gt;（2）在LLDB依次输入以下两条命令&lt;/p&gt;

&lt;h1 id=&quot;expr-classnsclassfromstringibarevealloader--nil--voiddlopenapplicationsrevealappcontentssharedsupportios-librarieslibrevealdylib-0x2--void0&quot;&gt;expr (Class)NSClassFromString(@”IBARevealLoader”) == nil ? (void&lt;em&gt;)dlopen(“/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib”, 0x2) : ((void&lt;/em&gt;)0)&lt;/h1&gt;

&lt;h1 id=&quot;expr-voidnsnotificationcenter-nsnotificationcenter-defaultcenter-postnotificationnameibarevealrequeststart-objectnil&quot;&gt;expr (void)[(NSNotificationCenter *)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStart” object:nil];&lt;/h1&gt;

&lt;p&gt;第一条命令用于加载Reveal的动态链接库；&lt;/p&gt;

&lt;p&gt;第二条命令用于启动Reveal调试服务。&lt;/p&gt;

&lt;p&gt;输入两条命令后，如果LLDB打印 “ INFO: Reveal Server started ” 即成功启动Reveal服务，点击Continue即可。&lt;/p&gt;

&lt;p&gt;虽然说输入两条命令即可启动服务，但是每次重新启动项目后都要重新输入这么长的命令也是挺苦恼的，下面介绍一种方法可以非常方便地使用Reveal的命令。&lt;/p&gt;

&lt;p&gt;二、设置LLDB命令别名
打开终端，输入 vim ~/.lldbinit ，然后输入以下内容：&lt;/p&gt;

&lt;p&gt;command alias reveal_load_sim expr (Class)NSClassFromString(@”IBARevealLoader”) == nil ? (void&lt;em&gt;)dlopen(“/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib”, 0x2) : ((void&lt;/em&gt;)0)&lt;/p&gt;

&lt;p&gt;command alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStart” object:nil];&lt;/p&gt;

&lt;p&gt;command alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStop” object:nil];&lt;/p&gt;

&lt;p&gt;reveal_load_sim为模拟器加载reveal调试用的动态链接库&lt;/p&gt;

&lt;p&gt;reveal_start启动reveal调试功能&lt;/p&gt;

&lt;p&gt;reveal_stop结束reveal调试功能&lt;/p&gt;

&lt;p&gt;输入 :wq 保存
这时候打开Xcode，在LLDB里面就会有输入提示了。&lt;/p&gt;

&lt;p&gt;按顺序输入reveal_load_sim –&amp;gt; reveal_start 即可达到上面的效果。&lt;/p&gt;

&lt;p&gt;参考资料
iOS开发中集成Reveal&lt;/p&gt;

&lt;p&gt;UI调试神器 for ios：Reveal的使用与破解&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Jan 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>iOS项目集成Reveal</title>
        <link>/iOS-Reveal/</link>
        <guid isPermaLink="true">/iOS-Reveal/</guid>
        <description>&lt;p&gt;Reveal是一款UI调试工具，在iOS开发过程中可查看UI的层级关系并可动态修改界面，可以有效提高开发效率。这篇文章主要介绍如何把Reveal集成到实际的项目中。&lt;/p&gt;

&lt;p&gt;一、Reveal主要有两种集成方式：
1、framework集成（可忽略，直接看第二点）
（1）打开Reveal，选择 Reveal –&amp;gt; Help –&amp;gt; Show Reveal Library in Finder –&amp;gt; iOS Library&lt;/p&gt;

&lt;p&gt;（2）把Reveal.framework导入到项目中&lt;/p&gt;

&lt;p&gt;（3）配置Target，Target –&amp;gt; Build Setting –&amp;gt; Other Linker Flags 添加以下4项：&lt;/p&gt;

&lt;p&gt;（4）运行项目 –&amp;gt; 打开Reveal –&amp;gt; 选择连接设备&lt;/p&gt;

&lt;p&gt;项目的UI图层就可以出来了。&lt;/p&gt;

&lt;p&gt;这种方法有几个弊端：1、需要配置项目的Build Setting，修改Other Linker Flags，多人协作开发的话如果有人没有配置就会编译出错；2、如果不留意容易打包的时候把Reveal的framework也打包进去，增大包的体积。&lt;/p&gt;

&lt;p&gt;以下推荐另一种集成方法。&lt;/p&gt;

&lt;p&gt;2、LLDB集成（推荐！！）
（1）运行项目 –&amp;gt; 点击Pause program execution。&lt;/p&gt;

&lt;p&gt;（2）在LLDB依次输入以下两条命令&lt;/p&gt;

&lt;h1 id=&quot;expr-classnsclassfromstringibarevealloader--nil--voiddlopenapplicationsrevealappcontentssharedsupportios-librarieslibrevealdylib-0x2--void0&quot;&gt;expr (Class)NSClassFromString(@”IBARevealLoader”) == nil ? (void&lt;em&gt;)dlopen(“/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib”, 0x2) : ((void&lt;/em&gt;)0)&lt;/h1&gt;

&lt;h1 id=&quot;expr-voidnsnotificationcenter-nsnotificationcenter-defaultcenter-postnotificationnameibarevealrequeststart-objectnil&quot;&gt;expr (void)[(NSNotificationCenter *)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStart” object:nil];&lt;/h1&gt;

&lt;p&gt;第一条命令用于加载Reveal的动态链接库；&lt;/p&gt;

&lt;p&gt;第二条命令用于启动Reveal调试服务。&lt;/p&gt;

&lt;p&gt;输入两条命令后，如果LLDB打印 “ INFO: Reveal Server started ” 即成功启动Reveal服务，点击Continue即可。&lt;/p&gt;

&lt;p&gt;虽然说输入两条命令即可启动服务，但是每次重新启动项目后都要重新输入这么长的命令也是挺苦恼的，下面介绍一种方法可以非常方便地使用Reveal的命令。&lt;/p&gt;

&lt;p&gt;二、设置LLDB命令别名
打开终端，输入 vim ~/.lldbinit ，然后输入以下内容：&lt;/p&gt;

&lt;p&gt;command alias reveal_load_sim expr (Class)NSClassFromString(@”IBARevealLoader”) == nil ? (void&lt;em&gt;)dlopen(“/Applications/Reveal.app/Contents/SharedSupport/iOS-Libraries/libReveal.dylib”, 0x2) : ((void&lt;/em&gt;)0)&lt;/p&gt;

&lt;p&gt;command alias reveal_start expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStart” object:nil];&lt;/p&gt;

&lt;p&gt;command alias reveal_stop expr (void)[(NSNotificationCenter*)[NSNotificationCenter defaultCenter] postNotificationName:@”IBARevealRequestStop” object:nil];&lt;/p&gt;

&lt;p&gt;reveal_load_sim为模拟器加载reveal调试用的动态链接库&lt;/p&gt;

&lt;p&gt;reveal_start启动reveal调试功能&lt;/p&gt;

&lt;p&gt;reveal_stop结束reveal调试功能&lt;/p&gt;

&lt;p&gt;输入 :wq 保存
这时候打开Xcode，在LLDB里面就会有输入提示了。&lt;/p&gt;

&lt;p&gt;按顺序输入reveal_load_sim –&amp;gt; reveal_start 即可达到上面的效果。&lt;/p&gt;

&lt;p&gt;参考资料
iOS开发中集成Reveal&lt;/p&gt;

&lt;p&gt;UI调试神器 for ios：Reveal的使用与破解&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Dec 2016 00:00:00 +0800</pubDate>
      </item>
    
  </channel>
</rss>
